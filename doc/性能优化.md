# TDSQL LOAD DATA INFILE 完整优化配置清单

from deepseek



## 一、命令行动态设置（立即生效）

### 1. **启动优化会话（需要SUPER权限）**

bash

```
# 1. 连接到TDSQL管理节点
mysql -h [host] -P [port] -u root -p

# 2. 设置全局优化参数（当前实例有效，重启后失效）
SET GLOBAL innodb_buffer_pool_size = 17179869184;  -- 16GB，根据内存调整
SET GLOBAL innodb_log_file_size = 4294967296;      -- 4GB
SET GLOBAL innodb_log_buffer_size = 268435456;     -- 256MB
SET GLOBAL innodb_flush_log_at_trx_commit = 2;     -- 降低刷盘频率
SET GLOBAL sync_binlog = 0;                        -- 关闭binlog同步
SET GLOBAL max_allowed_packet = 1073741824;        -- 1GB
SET GLOBAL net_buffer_length = 16777216;           -- 16MB
SET GLOBAL bulk_insert_buffer_size = 536870912;    -- 512MB
SET GLOBAL innodb_io_capacity = 4000;              -- SSD建议值
SET GLOBAL innodb_io_capacity_max = 8000;
SET GLOBAL innodb_read_io_threads = 8;
SET GLOBAL innodb_write_io_threads = 8;
SET GLOBAL innodb_purge_threads = 4;
SET GLOBAL innodb_page_cleaners = 4;
SET GLOBAL innodb_adaptive_flushing = ON;
SET GLOBAL innodb_flush_neighbors = 0;             -- SSD建议关闭
SET GLOBAL innodb_doublewrite = 0;                 -- 仅批量加载时关闭
SET GLOBAL innodb_checksum_algorithm = none;       -- 关闭校验
SET GLOBAL innodb_log_compressed_pages = OFF;      -- 减少日志大小
SET GLOBAL thread_pool_size = 32;                  -- 根据CPU核心数调整
```



### 2. **TDSQL特有参数（如果适用）**

sql

```
-- TDSQL分布式优化
SET GLOBAL tdsql_batch_commit_size = 1000000;
SET GLOBAL tdsql_parallel_load_threads = 8;
SET GLOBAL tdsql_skip_slave_check = 1;      -- 跳过从库检查
SET GLOBAL tdsql_load_data_memory_limit = 4294967296;  -- 4GB内存限制
```



## 二、配置文件永久设置（my.cnf / my.ini）

### 1. **基础配置段**

ini

```
[mysqld]
# 基础设置
port = 3306
datadir = /var/lib/mysql
socket = /var/lib/mysql/mysql.sock
log-error = /var/log/mysqld.log
pid-file = /var/run/mysqld/mysqld.pid

# 字符集
character-set-server = utf8mb4
collation-server = utf8mb4_general_ci
```



### 2. **内存优化（根据服务器内存调整）**

ini

```
# 内存配置（64GB内存服务器示例）
innodb_buffer_pool_size = 48G                    # 系统内存的70-75%
innodb_buffer_pool_instances = 8                 # 每个实例至少1GB
innodb_log_buffer_size = 256M
innodb_log_file_size = 4G                        # 每个日志文件大小
innodb_log_files_in_group = 2                    # 总共8GB日志空间

# 连接相关
max_connections = 1000
max_connect_errors = 100000
connect_timeout = 60
wait_timeout = 28800
interactive_timeout = 28800
```



### 3. **IO优化（SSD硬盘推荐）**

ini

```
# IO优化
innodb_flush_method = O_DIRECT                   # Linux使用O_DIRECT，Windows使用async_unbuffered
innodb_flush_log_at_trx_commit = 2               # 批量加载优化
innodb_doublewrite = 0                           # 批量加载时关闭
innodb_file_per_table = ON
innodb_data_file_path = ibdata1:1G:autoextend
innodb_autoextend_increment = 128

# SSD优化
innodb_io_capacity = 4000
innodb_io_capacity_max = 8000
innodb_read_io_threads = 8
innodb_write_io_threads = 8
innodb_flush_neighbors = 0                       # SSD关闭邻居页刷新
```



### 4. **批量加载专用配置**

ini

```
# 批量加载优化
bulk_insert_buffer_size = 512M
max_allowed_packet = 1G
net_buffer_length = 16M
read_buffer_size = 8M
read_rnd_buffer_size = 4M
sort_buffer_size = 4M
join_buffer_size = 4M
tmp_table_size = 256M
max_heap_table_size = 256M

# 事务和锁
transaction_isolation = READ-COMMITTED
innodb_lock_wait_timeout = 300
lock_wait_timeout = 300
innodb_rollback_on_timeout = ON
innodb_autoinc_lock_mode = 2                     # 交错自增锁
```



### 5. **日志和监控（可调整）**

ini

```
# 日志配置
log_bin = /var/log/mysql/mysql-bin.log
binlog_format = ROW
binlog_row_image = MINIMAL
expire_logs_days = 7
sync_binlog = 0                                  # 批量加载时关闭同步
binlog_cache_size = 1M
binlog_stmt_cache_size = 32K

# 慢查询和错误日志
slow_query_log = OFF                             # 批量加载时关闭
long_query_time = 10
log_queries_not_using_indexes = OFF
log_throttle_queries_not_using_indexes = 1000
```



### 6. **InnoDB高级优化**

ini

```
# InnoDB引擎优化
innodb_thread_concurrency = 0                    # 0=不限制
innodb_concurrency_tickets = 5000
innodb_commit_concurrency = 0
innodb_purge_batch_size = 300
innodb_purge_threads = 4
innodb_page_cleaners = 4
innodb_adaptive_hash_index = OFF                 # 批量加载时关闭
innodb_change_buffering = none                   # 批量加载时关闭
innodb_stats_on_metadata = OFF
innodb_stats_persistent = ON
innodb_stats_auto_recalc = OFF
innodb_adaptive_flushing = ON
innodb_adaptive_flushing_lwm = 10
innodb_flushing_avg_loops = 30
```



## 三、JDBC连接字符串优化

### 1. **标准MySQL JDBC URL**

java

```
String url = "jdbc:mysql://tdsql-host:3306/database?"
    + "useSSL=false&"
    + "rewriteBatchedStatements=true&"      // 批量语句重写
    + "useServerPrepStmts=false&"           // 禁用服务器端预编译
    + "cachePrepStmts=false&"               // 禁用预编译缓存
    + "useLocalSessionState=true&"          // 使用本地会话状态
    + "useLocalTransactionState=true&"
    + "maintainTimeStats=false&"            // 减少监控开销
    + "elideSetAutoCommits=true&"           // 优化自动提交
    + "cacheServerConfiguration=true&"      // 缓存服务器配置
    + "dontTrackOpenResources=true&"        // 不跟踪打开资源
    + "useUnbufferedInput=false&"           // 使用缓冲输入
    + "zeroDateTimeBehavior=convertToNull&"
    + "characterEncoding=utf8mb4&"
    + "connectionCollation=utf8mb4_general_ci&"
    + "socketTimeout=3600000&"               // 1小时socket超时
    + "connectTimeout=30000&"
    + "autoReconnect=true&"
    + "failOverReadOnly=false";
```



### 2. **TDSQL专用参数（如果支持）**

java

```
String tdsqlUrl = url 
    + "&tdsqlLoadDataMode=fast"              // TDSQL快速加载模式
    + "&tdsqlSkipSlaveCheck=true"            // 跳过从库检查
    + "&tdsqlBatchSize=1000000";             // 批量大小
```



## 四、LOAD DATA SQL语句优化模板

### 1. **完整优化模板**

sql

```
-- 预处理：禁用索引（加载前执行）
ALTER TABLE target_table DISABLE KEYS;

-- LOAD DATA优化命令
LOAD DATA 
    LOCAL                    -- 从客户端读取文件
    INFILE '/path/to/data.csv'
    REPLACE                  -- 或 IGNORE，根据业务需求
    INTO TABLE target_table
    CHARACTER SET utf8mb4
    
    -- 字段定义（必须精确匹配CSV格式）
    FIELDS
        TERMINATED BY ','    -- CSV用逗号分隔
        OPTIONALLY ENCLOSED BY '"'  -- 字段可选引号包围
        ESCAPED BY ''        -- 禁用转义，提高性能
        
    -- 行定义
    LINES
        TERMINATED BY '\n'   -- Unix/Linux换行符
        STARTING BY ''       -- 明确指定无起始符
        
    -- 跳过表头
    IGNORE 1 LINES
    
    -- 明确指定列顺序（重要！）
    (column1, column2, column3, @dummy1, @dummy2)
    
    -- 数据转换和计算字段
    SET
        created_at = IF(@created_at = '' OR @created_at IS NULL, 
                       NOW(), STR_TO_DATE(@created_at, '%Y-%m-%d %H:%i:%s')),
        updated_at = NOW(),
        status = 1,
        batch_id = CURRENT_BATCH_ID();

-- 后处理：重建索引和更新统计信息
ALTER TABLE target_table ENABLE KEYS;
ANALYZE TABLE target_table;
OPTIMIZE TABLE target_table;  -- 可选，如果碎片严重
```



### 2. **分片加载优化模板**

sql

```
-- 分片特定优化（如果TDSQL支持分片提示）
LOAD DATA LOCAL INFILE '/path/to/shard_data.csv'
INTO TABLE sharded_table
/*!tdsql:shard=shard_id*/    -- 分片提示（如果支持）
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n'
IGNORE 1 LINES
SET shard_id = CALCULATED_SHARD_ID();  -- 自动计算分片ID
```



## 六、操作系统级优化

### 1. **Linux系统参数优化**

bash

```
# 编辑 /etc/sysctl.conf
net.core.rmem_default = 262144
net.core.rmem_max = 16777216
net.core.wmem_default = 262144
net.core.wmem_max = 16777216
net.core.netdev_max_backlog = 10000
net.core.somaxconn = 65535
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216
net.ipv4.tcp_max_syn_backlog = 65536
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 0  # 不建议开启，可能导致NAT问题

# 文件系统参数
vm.swappiness = 10
vm.dirty_ratio = 60
vm.dirty_background_ratio = 5
vm.dirty_expire_centisecs = 3000
vm.dirty_writeback_centisecs = 500
fs.file-max = 65535
fs.aio-max-nr = 1048576

# 应用配置
sysctl -p
```



### 2. **文件系统挂载优化**

bash

```
# 如果TDSQL数据目录在XFS文件系统上
# /etc/fstab 添加noatime,nobarrier选项
/dev/sdb1 /var/lib/mysql xfs defaults,noatime,nobarrier,inode64 0 0

# 如果是ext4
/dev/sdb1 /var/lib/mysql ext4 defaults,noatime,nodelalloc 0 0
```



### 3. **磁盘调度器优化（SSD）**

bash

```
# 查看当前调度器
cat /sys/block/sdX/queue/scheduler

# 设置为noop或deadline（SSD）
echo noop > /sys/block/sdX/queue/scheduler

# 永久设置（编辑grub）
GRUB_CMDLINE_LINUX_DEFAULT="elevator=noop"
```



## 七、监控和调优脚本

### 1. **实时监控脚本**

bash

```
#!/bin/bash
# monitor_load.sh

# 监控LOAD DATA进程
mysql -u root -p -e "
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE,
    LEFT(INFO, 100) as SQL_SNIPPET
FROM 
    information_schema.PROCESSLIST 
WHERE 
    COMMAND = 'Query' 
    AND INFO LIKE '%LOAD DATA%'
ORDER BY 
    TIME DESC;
"

# 监控InnoDB状态
mysql -u root -p -e "SHOW ENGINE INNODB STATUS\G" | grep -A 10 "LOAD DATA"

# 监控系统负载
top -bn1 | grep "Cpu\|Mem"
iostat -dx 1 5
```



### 2. **性能分析脚本**

bash

```
#!/bin/bash
# analyze_load_performance.sh

# 分析LOAD DATA性能
LOG_FILE=$1

echo "=== LOAD DATA Performance Analysis ==="
echo ""

# 统计总行数和平均速度
grep "Rows" $LOG_FILE | awk '
BEGIN { total_rows=0; total_time=0; count=0 }
{
    split($0, parts, " ");
    rows = parts[2];
    time = parts[6];
    total_rows += rows;
    total_time += time;
    count++;
    speed = rows/time;
    printf "File %d: %d rows in %.2f sec (%.2f rows/sec)\n", 
           count, rows, time, speed;
}
END {
    if (count > 0) {
        avg_speed = total_rows/total_time;
        printf "\nTotal: %d files, %d rows, %.2f sec\n", 
               count, total_rows, total_time;
        printf "Average: %.2f rows/sec\n", avg_speed;
    }
}'

# 找出最慢的文件
echo ""
echo "Slowest files:"
grep "Rows" $LOG_FILE | sort -k6 -nr | head -5
```



## 八、恢复默认配置（加载完成后）

sql

```
-- 恢复安全设置（加载完成后执行）
SET GLOBAL innodb_doublewrite = ON;
SET GLOBAL innodb_flush_log_at_trx_commit = 1;
SET GLOBAL sync_binlog = 1;
SET GLOBAL innodb_adaptive_hash_index = ON;
SET GLOBAL innodb_change_buffering = all;

-- 重新启用监控
SET GLOBAL slow_query_log = ON;
SET GLOBAL log_queries_not_using_indexes = ON;
```



## 九、紧急情况处理

### 1. **中断正在执行的LOAD DATA**

sql

```
-- 1. 查找LOAD DATA进程ID
SHOW PROCESSLIST;

-- 2. 终止进程
KILL [process_id];

-- 3. 检查是否有未完成的事务
SELECT * FROM information_schema.INNODB_TRX\G
```



### 2. **恢复被中断的加载**

bash

```
# 使用检查点文件恢复
java -jar data-loader.jar \
    --resume \
    --checkpoint-file=/path/to/checkpoint.log \
    --start-from=500000 \
    --input-file=/path/to/data.csv
```



## 十、参数调优优先级（从高到低）

1. **🔥 紧急优化（立即见效）**
   - `unique_checks = 0`
   - `foreign_key_checks = 0`
   - `sql_log_bin = 0`
   - 文件拆分（避免超大事务）
2. **⚡ 重要优化（效果显著）**
   - `innodb_buffer_pool_size`（增大）
   - `innodb_log_file_size`（增大）
   - `max_allowed_packet`（增大）
   - 使用SSD存储
3. **✨ 进阶优化（边际收益）**
   - `innodb_io_capacity`（调整）
   - `innodb_flush_method`（优化）
   - 操作系统参数调优
   - 网络参数优化

**重要提醒**：

1. 先在测试环境验证所有配置
2. 记录每次优化的性能变化
3. 关注数据库错误日志和系统监控
4. 加载完成后及时恢复生产环境配置
5. 定期进行健康检查和参数复审

此清单覆盖了从数据库配置、JDBC优化到操作系统的全方位优化，根据实际硬件环境和数据特性调整具体数值。



# TDSQL分片连接和查询机制详解

## 一、TDSQL分片架构的基本原理

### 1. **TDSQL分片架构示意图**

text

```
┌─────────────────────────────────────────────────┐
│           应用程序 / 客户端                      │
│                │                                 │
│                ▼                                 │
│        ┌─────────────────┐                       │
│        │  TDSQL代理层     │                       │
│        │  (网关/路由)     │                       │
│        └────────┬────────┘                       │
│                 │ 解析SQL,计算路由                │
│        ┌────────┼────────┐                       │
│        ▼        ▼        ▼                       │
│   ┌────────┐┌────────┐┌────────┐                │
│   │ 分片1  ││ 分片2  ││ 分片3  │                │
│   │ MySQL  ││ MySQL  ││ MySQL  │                │
│   └────────┘└────────┘└────────┘                │
│         │        │        │                      │
│         ├────────┴────────┤                      │
│         ▼                 ▼                      │
│   ┌─────────────┐  ┌─────────────┐              │
│   │  数据节点1   │  │  数据节点N   │              │
│   └─────────────┘  └─────────────┘              │
└─────────────────────────────────────────────────┘
```



## 二、分片连接的两种模式

### 1. **模式1：通过代理层连接（推荐）**

java

```
// 应用程序 -> TDSQL代理 -> 自动路由到分片
// 这是正常的TDSQL使用方式

public class ProxyConnectionExample {
    
    public void queryThroughProxy() throws SQLException {
        // 连接TDSQL代理（网关）地址
        String proxyUrl = "jdbc:mysql://tdsql-proxy-host:3306/mydb";
        
        try (Connection conn = DriverManager.getConnection(proxyUrl, user, pass);
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT * FROM users WHERE user_id = 123")) {
            
            // TDSQL代理会自动：
            // 1. 根据user_id计算属于哪个分片
            // 2. 将查询路由到对应的分片
            // 3. 返回结果给应用程序
            
            while (rs.next()) {
                // 处理结果
            }
        }
    }
}
```



### 2. **模式2：直连分片节点（数据装载优化）**

java

```
// 应用程序 -> 直接连接特定分片的MySQL实例
// 用于批量数据装载，绕过代理层

public class DirectShardConnectionExample {
    
    private Map<Integer, String> shardConnections = new HashMap<>() {{
        put(0, "jdbc:mysql://shard0-host:3306/mydb");
        put(1, "jdbc:mysql://shard1-host:3306/mydb");
        put(2, "jdbc:mysql://shard2-host:3306/mydb");
    }};
    
    public void loadDataDirectToShards(Map<Integer, String> shardFileMap) {
        // 并行加载到每个分片
        shardFileMap.entrySet().parallelStream().forEach(entry -> {
            int shardId = entry.getKey();
            String filePath = entry.getValue();
            
            try (Connection conn = DriverManager.getConnection(
                    shardConnections.get(shardId), user, pass);
                 Statement stmt = conn.createStatement()) {
                
                // 直接在该分片执行LOAD DATA
                String sql = String.format(
                    "LOAD DATA LOCAL INFILE '%s' INTO TABLE users",
                    filePath
                );
                stmt.execute(sql);
                
                System.out.println("Loaded data to shard " + shardId);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        });
    }
}
```



## 八、关键问题解答

### **Q1：直连分片装载后，还能通过TDSQL整体查询吗？**

**A：可以的！** 因为：

1. TDSQL代理层维护了分片路由规则
2. 你直连分片装载的数据，物理上就在各个分片MySQL中
3. 代理层查询时，会根据路由规则去各个分片获取数据
4. 代理层负责聚合结果返回给客户端

### **Q2：直连分片装载和通过代理装载的区别？**

java

```
// 区别对比：
// 1. 直连分片装载：
//    - 优点：性能更高，绕过代理层开销
//    - 优点：可以并发装载到多个分片
//    - 缺点：需要自己处理分片逻辑
//    - 缺点：需要知道所有分片连接信息

// 2. 通过代理装载：
//    - 优点：使用简单，像操作单表
//    - 优点：自动处理分片路由
//    - 缺点：性能较低，代理层成为瓶颈
//    - 缺点：可能不支持大数据量直接装载
```



### **Q3：如何保证分片数据的一致性？**

1. **分片键唯一性**：确保同一分片键的数据只在一个分片
2. **事务边界**：单个分片内的事务是ACID的，跨分片事务需要额外处理
3. **最终一致性**：TDSQL通常提供最终一致性保证
4. **定期校验**：定期检查各分片数据分布和完整性

### **Q4：分片装载的挑战和解决方案**

java

```
// 挑战1：热点分片（某些分片数据特别多）
// 解决方案：优化分片键，使用更均匀的哈希算法

// 挑战2：跨分片查询性能
// 解决方案：
//   - 尽量使用分片键查询
//   - 避免全表扫描
//   - 使用分片内聚簇索引

// 挑战3：分片扩容
// 解决方案：
//   - 使用一致性哈希分片
//   - TDSQL通常提供在线扩容工具
//   - 规划时预留分片容量
```



## 九、总结

**分片连接**确实是把每个分片当作独立的MySQL实例来装载数据，但这**不影响**通过TDSQL代理层进行整体查询。实际上，这是大型分布式数据库的**标准做法**：

1. **数据装载阶段**：为了最高性能，直连各个分片并行装载
2. **数据查询阶段**：通过代理层透明查询，享受分布式数据库的便利

这种架构的优点是：

- **装载性能**：并发装载，线性扩展
- **查询透明**：应用程序无需关心数据在哪个分片
- **运维灵活**：可以单独管理每个分片

对于您的场景，您已经实现了正确的架构：拆分文件 → 并发装载到各分片。装载完成后，所有应用程序都可以通过TDSQL代理正常查询数据，就像查询单个数据库一样。




server:
  port: 8080 # 提供 HTTP 查询接口的端口

spring:
  application:
    name: moveprog
  autoconfigure:
    exclude: com.github.gavlyukovskiy.boot.jdbc.decorator.DataSourceDecoratorAutoConfiguration
  mvc:
    validation:
      enabled: true  # 默认就是 true
  web:
    resources:
      # 关键配置：指定静态资源查找路径
      # file:./static/ 表示当前运行目录下的 static 文件夹 (优先级高)
      # classpath:/static/ 表示 Jar 包内部的默认文件夹 (优先级低，作为兜底)
      static-locations: file:./static/, classpath:/static/

  # 1. 元数据库配置 (Spring 自动托管)
  # 数据库配置 (存放 qianyi_main, qianyi_detail 的元数据库)
  datasource:
    url: jdbc:mysql://localtestdb:3316/test1?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai&rewriteBatchedStatements=true&allowMultiQueries=true&tinyInt1isBit=false&yearIsDateType=false&allowPublicKeyRetrieval=true&connectTimeout=360000&socketTimeout=3600000&failOverReadOnly=false&failOverReadOnly=false&autoReconnect=true
    username: root
    password: 111111
    driver-class-name: com.mysql.cj.jdbc.Driver

    # 元数据库的 HikariCP 连接池设置
    hikari:
      pool-name: MetaHikariPool
      # 【核心策略】元库只做状态更新(UPDATE status=RUNNING)，耗时极短(ms级)。
      # 即使有 100 个线程在跑任务，30 个连接足够轮转过来。
      # 不要设太大，以免 5 台机器总连接数(5*30=150)对 MySQL 造成压力。
      maximum-pool-size: 30
      minimum-idle: 10
      # 状态更新非常快，如果 30秒 拿不到连接说明 DB 挂了
      connection-timeout: 30000
      # 验证连接有效性，防止拿旧连接报错
      validation-timeout: 3000
      # 只有 meta 库需要检测连接泄漏，防止开发写代码忘了关连接
      leak-detection-threshold: 2000

  # JPA 配置
  jpa:
    hibernate:
      ddl-auto: update # 第一次运行时会自动建表，生产环境建议改为 validate
    show-sql: false
    open-in-view: false

  # 线程池配置 (如果你启用了上面的虚拟线程 Bean，这里就不太重要了，但保留也没事)
  task:
    execution:
      pool:
        core-size: 10
        max-size: 50

# 自定义应用配置
app:
  # 【关键】指定本机身份
  current-node-ip: 192.168.37.100

  # CSV 配置
  csv:
    # 1. 源文件 IBM1388 配置
    ibm-source:
      # 核心编码
      encoding: IBM1388
      # [关键] 大机文件通常字段很多或很长，防止报错
      max-chars-per-column: 50000
      # 【自动探测全开】
      # 即使你下面配了 delimiter: ','，如果程序探测到文件里全是 '\t'，它会自动切换为 '\t'
      detect-line-separator: true
      detect-delimiter: true
      detect-quote: true
      detect-sample-rows: 2000
      # 即使开启了自动探测，也可以留着这些作为“探测失败”后的默认值
      line-separator: "\n"
      # 假如源文件用分号分隔
      delimiter: ","
      # 假如源文件不带引号
      #quote: "\0"  # 这是一个特殊技巧，用空字符表示无引号
      quote: "\""
      tunneling: true
      ignore-leading-whitespaces: true
      ignore-trailing-whitespaces: true
      null-value: ""
      quote-escape: "\""
      header-extraction: false

    # 2. 中间文件 UTF-8 配置
    utf8-split:
      encoding: UTF-8
      line-separator: "\n"
      delimiter: ","
      quote: "\""
      quote-escape: "\""
      null-value: ""

  # 3. 性能参数调优
  performance:
    read-buffer-size: 16777216  # 16MB (读取大文件建议加大)
    write-buffer-size: 2097152  # 2MB
    # Split JDBC 模式：文件大小 10MB (约 5-10万行),	Load Data 模式：50MB (约 20-50万行), JDBC 模式文件小一点，重试成本低
    split-rows: 100000          # 多少行切分一个文件
    max-chars-per-column: 100000 # 防止某些超长备注导致OOM

  executor:
    # ==========================================
    # 2. 线程池配置 (各司其职)
    # ==========================================
    # --- 转码 (CPU 密集型) ---
    transcode:
      # 128核 CPU，即使留出一半给系统和 GC，给 64 个核心跑计算也是安全的。
      # 这是一个纯 CPU + 本地 SSD 读写的操作，不涉及网络 IO，线程数≈核心数效率最高。
      core-size: 64
      max-size: 64
      # 队列稍微大点，作为缓冲
      queue-capacity: 500

    # --- 装载 (IO/网络 密集型) ---
    load:
      # 瓶颈在网络 RTT 和 TDSQL 写入速度。
      # 需要较多线程来填满网络等待时间。
      # 设定为 50，留出余量给 Verify。
      core-size: 50
      max-size: 50
      queue-capacity: 200

    # --- 验证 (IO/网络 密集型) ---
    verify:
      # 验证是 SELECT Count/Sum，速度通常比 Insert 快。
      # 给 20 个并发足够追平 50 个 Load 的产生速度。
      core-size: 20
      max-size: 20
      queue-capacity: 200


  # ==========================================
  # 3. 目标库连接池模板 (Target DB)
  # ==========================================
  # 目标库连接池的“默认模板配置”
  # 这些值会被注入到 AppProperties 中，供 TargetDatabaseConnectionManager 使用
  target-db-config:
    # Load线程(50) + Verify线程(20) = 70 并发。
    # 连接池必须 >= 70，否则线程拿不到连接会报错或空转。
    # 给 80 是为了留 10 个余量给临时查询或 Admin 操作。
    max-pool-size: 80
    # 保持一定的热连接，避免每次突发任务都要三次握手
    min-idle: 20

    # 目标库可能会因为繁忙响应慢，稍微容忍久一点的等待
    connection-timeout: 60000

    # JDBC Batch 必须关闭自动提交(不能修改此配置)
    auto-commit: false

    # 一个连接最长存活 30 分钟，防止服务端因为 wait_timeout 踢掉
    max-lifetime: 1800000sss

  transcode-job:
    max-error-count: 1000

  load-jdbc:
    pre-sql-list:
      - "SET unique_checks=0"
      - "SET foreign_key_checks=0"
    batch-size: 5000
    use-local-infile: false
    column-quote-char: "`"
    max-retries: 3
    query-timeout: 600

  verify:
    strategy: USE_SOURCE_FILE
    max-diff-count: 1000
    #fetch-size: -1

logging:
  level:
    org:
      hibernate:
        SQL: INFO
        type:
          descriptor:
            sql:
              BasicBinder: INFO
        orm:
          jdbc:
            bind: INFO
  # P6Spy 配置 (前提是引入了 p6spy-spring-boot-starter)
  decorator:
    datasource:
      enabled: false
      p6spy:
        enable-logging: false
        # 开启多行变单行，去掉了换行符，方便复制
        multiline: true
        # 自定义日志格式：执行时间 | SQL语句
        log-format: "%(executionTime) ms | %(sql)"